Лекция 21.
PHP: распространенные паттерны уязвимостей
@alagunto Николай Ткаченко

#TODO study php

shadow servants

Популярные уявимости: 
1) ошибки кофигурации
2) бекдорные роуты ( путь к кприложению)- оставили разрабы
3) sql  - инъекц
4) нерабочая валидация (проверки на корректность. Проверка на то, что реальное и жеалаемое совпадают)
5) коварные опечатки
6) null - буллшит - позже
7) sessions rollback - восстановление сессий
8) ssrf - сессионные ошибки


Конфиг файл
Framework: 
1.Laravel:
	1. .env  тут все файлы хранятся
	2. config/ потом они попадают сюдя

2. Yii2
	comon/coonfig

Без фреймворка:
1) grep ( поиск по текущей папке) -ri config.
2) grep -ri key
3) password

Искать:
10 токены
2) нестанд значения
3) нестанд ключи

Функции получения конфигов: 
Laravel('key')

Yii2

поск по слову конфиг

Ищем магические константы
phpmnd, phpstan - для автоматического поиска

Бекдорные роуты -  те пути в сайте, которые не должны сущ - ть
Laravel
route:get('/debug') - получение доступа к пользовательским данным

Где искать ? 
routes/*

Yii2:
только грепом
чаще всего забывают эти роуты

Если  не популярные фрейморки:
Routes autoresolving 
1) controller ename + method name
2) правила перевода смотреть по имеющимся ссылкам
3) обыно является причиной дырок - позволяют вызвать другие функции

Что искать в целом:
1) искать код без контроллеров
2) контроллеры с единственноым методом
3) контроллеры которые не далко удалить
4) админский роут
5) что угодно: raw, key

Ищите:
1) статиту с логами
2) статику с бд
3) то, чего не должно быть
4) то, что бросается в глаза

SQL - injections
Как проверять:
1) берем назввание проекта 
2) laravel raw query
3) грепааем по этому и готово

Что еще погрепать для поиска скл инъекц:
1) select
2) 

grep:
1) raw
2) execute
3) Query

Нерабочая валидация
Почему так происходит:
1) если механизмы проверки данных
2) 

Что делать:
1) вручную проверять валидацию, посылая плохие данные
2) не доверять никаким данным, если она валидируется

CTF:
 наглое изменение переменной приводит к получению флага

Опечатки
1) он динамический
2) почему именно динамический - низкий порог вхождения 

если в контроллере будет опечатка, то он станет публичным, тогда behaviour  
Laravel: если при вызове метода, то ошибку выдаст. А если не в конструкторе, то тогда будет ошибка и контроллер становится не публичным

В IDE: обращать внимание на зеленую линию

Null - bullshit:
1) нет возврата функции 0
2) null == 0, <-1, false, [], ""
	при сравнении с положительными он ведет себя как 0

	при помощи == могут две строки стать одинаковыми
Как это может помешать:
уязвимость Laravel:
	есть модуль для расшифровки / шифровки
	он мог неожиданно выкинуть false
	потом происходит сравнение, истинность и продолжается работа

Что делать: 
1) искать == и менять ===. Это еще делает проверку типов
2) искать <. >, <= и валидировать типы
3) валидировать типы на всех вводимых данных
4) быть готовым получить null из любой функции. Может начаться магия

Важные фишка: 
	есть type hidding
	*можно передать все что похоже на стринг, например, число
	*а если ввести строку, а надо число, то она сконвертится в число

Seccion rollback:
Сессия - способо хранения данных для пользователяю человек просто обновляет страничку, но это он же

1) в большинстве php - фреймворков сессия по умолчанию реализована через cookies
	можно вообще в блокнот сохранить и что - то делать
2) мы не можем подделать значения
3) можем восстановить старые

Паттер1: 
1) одноразовое действие х
2) флаг ставится если х было
3) доступ к действия предоставляется по флагу
4)

Паттерн2:
1) есть rate - limiting per session (обычно отправка смс о восстановл)
2) сессия на стороне клиента хранится
3) восстанавливать старую куку можно бесконечно

Что делать:
1) искать использованные сессииэ
2) искать ползование сессий сильными разработчикаи

SSRF -  совершение запроса от имени сервера
kibana, elastic, backend. curl, me

В гугл таблицу: вставляется картинка в ячейку, url. Тянем ячейку, гугл тянет всеми своими серверами, сайт падает. ddos - атака

1) ssrf  - самая распростаненная ошибка
2) эту ошибку могут допустить даже опытные
3) последствия катастрофиные
4) разработчики библиотек не задумываются о клиентах

Можно контролировать опции, которые отправляются на сайт

SMTP header injection:
	есть заголовки
	при отправке сообщения когда ставим не туда, куда надо, а куда захотим

	как исправить: валидация присылаемых данных

GuzzleHttp header inj - для осуществления запросов 
разрешение переноса строки в заголовках
если 2 переноса строки, то можно сделать еще один запрос. Потому что если он уже авторизован, то может отправлять любое количество запросов.

github/ShadowCTF
vk.com/alagunto

magic numbers detector phpmnd

лекция в канале телеге

если можно только перенос строки без  контроля заголовков, то тогда ничего не сделаешь.





