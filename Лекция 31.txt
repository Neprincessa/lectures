Лекция 31.
Решетки в криптографии и криптоанализе. 

Решетка - конечно порожденная (имеющая конечную систему образующих) подгруппа Rn
Ранг элемента группы - количнство элементов, которое достаточно для представления любого элемента группы

Если ранг решетки равен n, то решетка полная 
Элемент конечного порядка - элемент а, для которого справедливо са = 0 при некотором с
Ранг - инвариант группы

Базис - набор лнз векторо Rn
Решетка - набор всевоможных комбинаций L = c1b1+c2b2+cmbm с целыми коэффициентами
базис не единственен

Классы сложности задач:
Задачи разрешимости - множество задач с ответом да / нетт
1) NP  задачи: для которых есои да и налиия сертификата решения можно проверить разрешимость за полиномиальное время (решаются недетерменированной мт за полиномиальное время)
2) co-NP - задачи, для которых в случае ответа задач ответа "нет" можно проверить неразрешимость за полиномиальное время
3) p задачм могут быть разрещшены за полиномиальное время
4) np - полные задачи - задачи класса NP к которым можно свести любую другую задачукласса NP за полиномиальное время
5) NP - 
(ДОПИСАТЬ) 
сфера коха - представление квантового бита

SVP: 
1. поиск кратчайшего вектора 
2. ближайшего вектора 
 
 Задача определения длниеы наикратчайшего вектора решетки

 Различие между рещетками, в которых длина кратчайшего вектора не превосходит d
 GavSVP - различие между решетками, в коорых длина кратчайщего пти не превосходит d или больше yd 
(смотреть фотку)


SVP -  поиск кратчайшего вектора 

CVP - нахождение ближайшего вектора 
Точные задачи: нахождение ближайшего вектора или yCVP - найти вектор на расстоянии не больше y

Метод ближайшей гиперплоскости Babai: 
На основе базиса строятся гиперплоскости и ищется плоскость, ближайшая к точке, соответствующей данному вектору.
Правильность решения зависит от используемых базисов. Метод лучше всего работает для базисов,в которых вектора коротки и практически ортогональны


Округление методом Babai:

Округление Babai
есть базис (записан по столбцам)
есть приблизительное значение точки
ищем Li и округляем до целых значений

Другие задачи:
BDD
LWE — learning with errors — задача обучения с ошибками

Криптосистемы на решётках — GGH — схема асимметричного шифрования и подписи, основанная на проблеме CVP.
Открытый ключ — базис, полученный с помощью произведения матриц (двух закрытых ключей).
Вектор ошибок нужен, чтобы невозможно было получить 
Вектор ошибок мб любым, вырабатывают в соответствии с обратным распределением.

Зашифрование 
Расшифрование — округление методом Бабай в исходном адресе

Goldreich-Goldwasser-Halevi:
Вектор ошибок гужен чтобы можно было получиьб 
вектор оишбок мб любым, вырабатывают в соответствии с обратным распредлением

Зашифрование - 
расшифрование - округление методом Бабай в исходном адресе

Regev system (на LWE)
Открытый ключ: а,б
Зашифрование - для кжадого бита сообщения k выполняется:
	выбирается случайно среди всех 2 в степ m подмножеств открытого ключа
	нужно выбрать нужные биты из матрицы открытого ключа

Существует более эффективная система: 
q = poly(n)
Секретный ключ - случайно выбранная матрица. Матрица ошибок 
Открытый ключ: открытй ключ из а и р - матриц (STA - транспонированная матрица*а)

Зашифрованное сообщение 
(смотреть фото) 

Суть: экономия места при сохранении 1 бита зашифрованной инфы

Ортогонализация Грамма - Шмидта

Позволяет привести базис к ортогональному виду, но сама по себе не применима к решетке, т.к. полученные вектора могут не принадлежат решеетке
но можем определить степень ортогональности базиса. Если длины векторов базиса убывают, базис далек от ортогонального

С-приведенные базисы
1) По зигелю
	второе условие означает, что длины элементов базиса не слишком уменьшаются
	первое означает, что вектора близки к ортогональным
2) по ловасу  - LLL
	все LLL  приведенные являются с - привееднными по зигелю
Отличие в последнем векторе, в его длине. Подробнее - смотреть фото

Алгоритм LLL:
	не ортогональны, но близки к ортогон и имеющим неб длину

На фото пример алгоритма
Вычитаем 1ый столбец 5 раз, потому что окпугляем мю-kl до ближайшего. округляем что -то в первом столбце матрицы м и получили 5
Суть вообще была в том: чтобы получить из базиса почти ортогональных векторов короткой величины, которые являются базисом конечной решетки

Задача о ранце: 
множество предметов обладающих весом. Определить сколькок предметов каждого вида можно взять, чтобы вес соотвествовал определенным значениям.
M 
Вектор X

Криптосистемы строятся на ней: 

Задача о ранце 0-1: 
	1. упорядоченное значение чисел 
	2. вектор из целых чисел

Есть открытый ключ - T = [575,436,1586,1030,1921,569,721,1183,1570] ...исходя из количества элементов тут, получаем количество 
Зашифровано из 9 бит X = (x1, ...,x9)
Скалярное равно 6665
Вместо чиселок ставить 0/1 до тех пор пока скалрное не будет равно указанному числу
В эффективных алгоритмах: дерево перебора. Эффективность за счет отсекания ветвей, тип слишком большие / маленькие


Решение задачи о рюкзаке с помощью решеток: 
1) нужно подобрать базис 
2) базис дб таким: он включает элементы Т такие, что после приведения после алгоритма LLL мы получили матрицу, из которой получим X
	определить базис за полиномиальное время 
Прежде чем проверять условия - надо составить матрицу Т
	2 условие — каждый предыдущий базис меньше или равен, чем последующий.
	1 условие — элементы уменьшаются не слишком быстро.

Как сделать эту т?
Надо сделать валидную матрицу решетки. В ней валидные ЛНЗ вектора, с помощтью нее можно найти задачу о рюкзаке


Ортогональный базис
Главная диагональ матрицы - не всегда только из нее состоит, еще состоит и из других элементов
В алгоритме несмотря на то,что записываем по вертикали координаты базисов, а потом считаем, что координаты базиса - это горизонталь. (В какой момент? )

НАКАНЕЦТА. Решение.
В криптографии:
	есть некоторый закрытый ключ (сверхвозрастающая), которая позволяет решить эту задачу легко

	1,3,7,15 - сверхвозр.
	1,2,4,8,16 - закрытый ключ 
	Если взять любую сумму, например,37. Можно легко получить вектор из 1,2,4,8,16. Нолики и единички ставим где надо
	Вычитаем максимально возможное число из нашей суммы

	С помощью преобразований делаем открытый из закрытого ( в вики есть алг с взятием по модулю. Надо уточнить, вроде там точно видела) 
	Криптосистемы: Ника - Хэлмана

Для некоторых последовательностей задача о рюкзаке становится тривиальной. 
Восстановить перехвативший не может за полиномиальное время, потому что ему надо перебрать все возможные варианты 

Боб получает сумму. И расшифровывает по закрытому ключу, который у него уже имеется

При использовании LLL мы отнимаем по координатно от столбца другой столбец 

Надо сделать так, чтобы сумма с некоторым коэффициентами минус число = сумме = 6665 было как можно ближе к нулю. 

Коллизии хэш - функций FNV-2
NSUCrypto-2017

В решетку подставляются значения хэшей. 
Разница первого и вторго хэша полученнных через lll, получаем цепочку хэшей 

В результате алг - ма LLL получается несколько столбцов с одинаковыми значениями на конце, в том числе с результами дял которых, хэш функция будет иметь коллизии

Почему 1 варик лучше 2го (смотреть слайд Коллизии хэш - функций FNV-2)
Берем коллизии и пытаемся получить все тоже самое, но только с помощью сложения по модулю ( это в коде что написано)

Проблема LWE в задачах CTF
Дано: матрица [random] и результат операции
Отличительные черты - небольие по сравнению с порядком поля
Найти: вектор secret [noise опционально]
Задача CVP:
	приблизительно решается с помощью метода Babai